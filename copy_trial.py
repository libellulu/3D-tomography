import numpy as np
from test_gaussian import gaussian_zz_cone
from algo_tomo_new import final_function
from algo_tomo_new import max_z_among_all_CCD
from reconstructions import tikhonov
import matplotlib.pyplot as plt
from collections import defaultdict

def comparison(printplot,nb_cell_x,nb_cell_z,spacing_x,spacing_z,nb_voxel_x,nb_voxel_y,nb_voxel_z,radius_tokamak,pinhole_to_CCD1,pinhole_to_CCD2,pinhole_to_CCD3,alpha):
    """
    Function that compares the reconstruction of the signal with the generated
    signals
    The plasma phantom signal is generated by gaussian_zz_cone and stored in
    scalar field values. The plasma generation can be change directly inside of
    this function (the argument of gaussian_zz_cone are not argument of comparison)
    The reconstruction is made by tikhonov, and the argument alpha is to be
    defined in the argument of comparison

    Parameters
    ----------
    printplot : 1 if we want to print the reconstruction picture, 0 otherwise
    nb_cell : the number of cell of the CCD in x or z
    spacing : the space between the center of two cell
    nb_voxel : discretization of the space in x,y, or z
    radius tokamak : for ISTTOK, 100
    pinhole distance to array : the distance between senser and pinhole, has to
    be tuned to get the best reconstruction
    alpha : alpha parameter of the reconstruction algorithm that weights the
    smoothness against the similarity of the reconstructed profile
    has to be tuned for the best reconstruction

    Returns
    -------
    g : the reconstructed signal
    scalar_field_value : the plasma phantom
    """
    real_projection,maxz=final_function(nb_cell_x,nb_cell_z,spacing_x,spacing_z,nb_voxel_x,nb_voxel_y,nb_voxel_z,radius_tokamak,pinhole_to_CCD1,pinhole_to_CCD2,pinhole_to_CCD3)


    # Test plot --------------------------------------------
    # In this example the distribution starts in the center,
    # and then moves to the top right corner while shrinking


    x_min, x_max = (-radius_tokamak, radius_tokamak)
    y_min, y_max = (-radius_tokamak, radius_tokamak)
    z_min, z_max = (-maxz,maxz)

    x_points, y_points, z_points = (nb_voxel_x,nb_voxel_y,nb_voxel_z)

    x_array = np.linspace(x_min, x_max, x_points)
    y_array = np.linspace(y_max, y_min, y_points)
    z_array = np.linspace(z_min, z_max, z_points)

    scalar_field_coordinates = np.meshgrid(z_array, y_array, x_array, indexing='ij')

    scalar_field_values_1 = gaussian_zz_cone(x=scalar_field_coordinates[2].flatten(),
                                           y=scalar_field_coordinates[1].flatten(),
                                           z=scalar_field_coordinates[0].flatten(),
                                           base_1=-150, base_2=150,
                                           mu_x_1=-15, mu_x_2=-15,
                                           mu_y_1=-15, mu_y_2=-15,
                                           sigma_x_1=25, sigma_x_2=25,
                                           sigma_y_1=25, sigma_y_2=25)

    scalar_field_values_2 = gaussian_zz_cone(x=scalar_field_coordinates[2].flatten(),
                                       y=scalar_field_coordinates[1].flatten(),
                                       z=scalar_field_coordinates[0].flatten(),
                                       base_1=-100, base_2=100,
                                       mu_x_1=-45, mu_x_2=60,
                                       mu_y_1=-50, mu_y_2=130,
                                       sigma_x_1=15, sigma_x_2=15,
                                       sigma_y_1=15, sigma_y_2=15)
    scalar_field_values = (scalar_field_values_1+scalar_field_values_2).reshape((z_points, y_points, x_points))

    if printplot==1:
        fig, axes = plt.subplots(1, len(scalar_field_values))

        for ax, cross_section in zip(axes, scalar_field_values):
            ax.imshow(cross_section)


    # Simulate tomography signals --------------------------------------------------

    fname = 'projections.npy'
    print('Reading:', fname)
    projections = np.load(fname)

    print('projections:', projections.shape, projections.dtype)

    # -------------------------------------------------------------------------

    P = projections.reshape((projections.shape[0], -1))

    print('P:', P.shape, P.dtype)

    signals = np.dot(P, scalar_field_values.flatten())

    print('Signals:', signals.shape, signals.dtype)

    np.save("signals.npy", signals)
    np.save("phantom.npy", scalar_field_values)


    g = tikhonov(signals,alpha)

    if printplot==1:

        fig, axes = plt.subplots(1, len(g))
        for g_cut, ax in zip(g, axes):
            ax.imshow(g_cut)
        plt.show()
        
    return g,scalar_field_values

def unitest():
    accuracy_list= []

    alpha_list=[]
    for alpha in (0.02,0.03,0.04,0.06,0.07,):
        g,plasma=comparison(0,30,3,0.979,0.112,18,18,3,100,5,5,5,alpha)
        accuracy=1-(np.sum(np.abs(g-plasma))/(np.sum(plasma)))
        accuracy_list.append(accuracy)

        alpha_list.append(alpha)
        print('alpha', alpha)
        print('mylist',accuracy_list)

    maximum=max(accuracy_list)
    print('max array',maximum)
    index_max=accuracy_list.index(maximum)
    print('index',index_max)
    print('optimum parameters','n=',n_list[index_max],'alpha=',alpha_list[index_max],'accuracy=',accuracy_list[index_max])
    return maximum,index_max


    return accuracy


def control_nb_cells():
    # tuning of the x and z number of cells
    accuracy_list= []
    n_list= []
    alpha_list=[]
    n=2

    for alpha in (0.02,0.05,0.08):

        if n ==2 :
            print('surviving',n,alpha)
            g,plasma=comparison(1,16,n,0.95,0.95,18,18,3,100,5,5,5,alpha)

            accuracy=1-(np.sum(np.abs(g-plasma))/(np.sum(plasma)))
            accuracy_list.append(accuracy)
            n_list.append(n)
            alpha_list.append(alpha)
            print('mylist',accuracy_list)

    maximum=max(accuracy_list)
    print('max array',maximum)
    index_max=accuracy_list.index(maximum)
    print('index',index_max)
    print('optimum parameters','n=',n_list[index_max],'alpha=',alpha_list[index_max],'accuracy=',accuracy_list[index_max])
    return maximum,index_max

#control number of voxel
def control_nb_voxels():
    # tuning of the x and z number of cells
    accuracy_list= []
    n_list= []
    alpha_list=[]


    for alpha in (0.2,0.3,0.4):

        for n in (5,20):

            print('surviving',n,alpha)
            g,plasma=comparison(1,4,4,3,3,n,n,3,100,20,alpha)

            accuracy=1-(np.sum(np.abs(g-plasma))/(np.sum(plasma)))
            accuracy_list.append(accuracy)
            n_list.append(n)
            alpha_list.append(alpha)
            print('mylist',accuracy_list)

    maximum=max(accuracy_list)
    print('max array',maximum)
    index_max=accuracy_list.index(maximum)
    print('index',index_max)
    print('optimum parameters','n=',n_list[index_max],'alpha=',alpha_list[index_max],'accuracy=',accuracy_list[index_max])
    return maximum,index_max

#control distance to pinhole
def control_dist_pinhole():
 # trying for a 4x4, with its best para : nb voxel =15,alpha 0.3
    accuracy_list= []
    n_list= []
    alpha_list=[]


    for alpha in (0.12,0.15,0.17):

        for n in (8.7,9,9.3):

            print('surviving',n,alpha)
            g,plasma=comparison(0,30,3,0.98,0.112,20,20,3,100,n,n,n,alpha)
            plt.show()
            accuracy=1-(np.sum(np.abs(g-plasma))/(np.sum(plasma)))
            accuracy_list.append(accuracy)
            n_list.append(n)
            alpha_list.append(alpha)
            print('mylist',accuracy_list)

    maximum=max(accuracy_list)
    print('max array',maximum)
    index_max=accuracy_list.index(maximum)
    print('index',index_max)
    print('optimum parameters','distance=',n_list[index_max],'alpha =',alpha_list[index_max],'accuracy=',accuracy_list[index_max])
    return maximum,index_max

max, imax=control_dist_pinhole()
print('out of function', max,imax)
#unitest()
#g,plasma = comparison(1,30,3,0.98,0.112,20,20,3,100,8.35,8.35,8.35,0.2)
#accuracy=1-(np.sum(np.abs(g-plasma))/(np.sum(plasma)))
#print('accuracy=',accuracy)
