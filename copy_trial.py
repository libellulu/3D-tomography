import numpy as np
from gaussian_blob import gaussian_zz_cone
from gaussian_blob import flattop
from gaussian_blob import gaussian_3d
from algo_tomo_new import final_function
from algo_tomo_new import max_z_among_all_CCD
from reconstructions import tikhonov
import matplotlib.pyplot as plt
from collections import defaultdict

def comparison(printplot,nb_cell_x,nb_cell_z,spacing_x,spacing_z,nb_voxel_x,nb_voxel_y,nb_voxel_z,radius_tokamak,alpha):
    """
    Function that compares the reconstruction of the signal with the generated
    signals
    The plasma phantom signal is generated by gaussian_zz_cone and stored in
    scalar field values. The plasma generation can be change directly inside of
    this function (the argument of gaussian_zz_cone are not argument of comparison)
    The reconstruction is made by tikhonov, and the argument alpha is to be
    defined in the argument of comparison

    Parameters
    ----------
    printplot : 1 if we want to print the reconstruction picture, 0 otherwise
    nb_cell : the number of cell of the CCD in x or z
    spacing : the space between the center of two cell
    nb_voxel : discretization of the space in x,y, or z
    radius tokamak : for ISTTOK, 100
    pinhole distance to array : the distance between senser and pinhole, has to
    be tuned to get the best reconstruction
    alpha : alpha parameter of the reconstruction algorithm that weights the
    smoothness against the similarity of the reconstructed profile
    has to be tuned for the best reconstruction

    Returns
    -------
    g : the reconstructed signal
    scalar_field_value : the plasma phantom
    """
    real_projection,maxz=final_function(nb_cell_x,nb_cell_z,spacing_x,spacing_z,nb_voxel_x,nb_voxel_y,nb_voxel_z,radius_tokamak)

    # Test plot --------------------------------------------
    # In this example the distribution starts in the center,
    # and then moves to the top right corner while shrinking


    # Test gaussian_3d and flattop ------------------------------------------------------------

    x_min, x_max = (-100, 100)
    y_min, y_max = (-100, 100)
    z_min, z_max = (-4, 4)

    x_points, y_points, z_points = (nb_voxel_x,nb_voxel_y,nb_voxel_z)

    x_array = np.linspace(x_min, x_max, x_points)
    y_array = np.linspace(y_max, y_min, y_points)
    z_array = np.linspace(z_min, z_max, z_points)

    scalar_field_coordinates = np.meshgrid(z_array, y_array, x_array, indexing='ij')

    x_coordinates = scalar_field_coordinates[2].flatten()
    y_coordinates = scalar_field_coordinates[1].flatten()
    z_coordinates = scalar_field_coordinates[0].flatten()

    blob_z = np.linspace(-8, 8, 5)
    phantoms = []

    for z in blob_z:

        phantom = flattop(x=x_coordinates, y=y_coordinates,
                          center_x=0, center_y=0, width=85 * 2, height=1, degree=2)

        phantom += gaussian_3d(x=x_coordinates, y=y_coordinates, z=z_coordinates,
                               mu_x=20, mu_y=20, mu_z=z,
                               sigma_x=5, sigma_y=5, sigma_z=4,
                               height=4)

        phantoms.append(phantom.reshape((z_points, y_points, x_points)))

    if printplot==1:

        fig, axes = plt.subplots(len(phantoms), z_points)

        for sub_axes, phantom in zip(axes, phantoms):
            for ax, cross_section in zip(sub_axes, phantom):
                im = ax.pcolormesh(np.linspace(-100, 100, x_points + 1),
                                   np.linspace(100, -100, y_points + 1),
                                   cross_section,
                                   vmin=0, vmax=2)
                ax.set_aspect('equal', adjustable='box')

        fig.colorbar(im, ax=axes.ravel().tolist())

        plt.show()

    # Simulate tomography signals --------------------------------------------------

    fname = 'projections.npy'
    print('Reading:', fname)
    projections = np.load(fname)

    #print('projections:', projections.shape, projections.dtype)

    # -------------------------------------------------------------------------

    P = projections.reshape((projections.shape[0], -1))

    #print('P:', P.shape, P.dtype)

    g_list=[]
    signal_list=[]

    for i in range(0,len(phantoms)):
        signals = np.dot(P, phantoms[i].flatten())


        print('Signals:', signals.shape, signals.dtype)


        np.save("signals.npy", signals)
        np.save("phantom.npy", phantoms)

        g=tikhonov(signals,alpha)
        g_list.append(g)
        #
        # if printplot==1:
        #
        #     fig, axes = plt.subplots(1, len(g))
        #     for g_cut, ax in zip(g, axes):
        #         ax.imshow(g_cut)
        #     plt.show()

    if printplot==1:

        fig, axes = plt.subplots(len(g_list), z_points)

        for sub_axes, phantom in zip(axes, g_list):
            for ax, cross_section in zip(sub_axes, g):
                im = ax.pcolormesh(np.linspace(-100, 100, x_points + 1),
                                   np.linspace(100, -100, y_points + 1),
                                   cross_section,
                                   vmin=0, vmax=2)
                ax.set_aspect('equal', adjustable='box')

        # fig.colorbar(im, ax=axes.ravel().tolist())

        plt.show()

    return g_list,phantoms

def unitest():
    accuracy_list= []
    optimal_alpha_list=[]
    optimal_accuracy_list=[]
    alpha_list=[]
    for i in range(5):
    #for i in [2,3]:
        print('firsti', i)
        for alpha in [2000]:
        #for alpha in list(np.arange(500,3000,100)):
            g,plasma=comparison(0,20,9,0.65,0.04,20,20,3,100,alpha)
            print('length of g',len(g))
            print('length plasma',len(plasma))
            accuracy=1-(np.sum(np.abs(g[i]-plasma[i]))/(np.sum(plasma[i])))
            print('serie',i)
            fig, axes = plt.subplots(1, len(g[i]))
            for g_cut, ax in zip(g[i], axes):
                ax.imshow(g_cut)
            plt.show()
            accuracy_list.append(accuracy)

            alpha_list.append(alpha)

            print('alpha', alpha)
            print('mylist',accuracy_list)
        print('serie',i)
        maximum=max(accuracy_list)

        print('max array',maximum)
        index_max=accuracy_list.index(maximum)
        alpha_max=alpha_list[index_max]
        #print('index',index_max)
        print('optimum parameters','alpha=',alpha_list[index_max],'accuracy=',accuracy_list[index_max])
        accuracy_list= []
        alpha_list=[]
        optimal_accuracy_list.append(maximum)
        optimal_alpha_list.append(alpha_max)
    print ('list of alphas',optimal_alpha_list)
    print('list of accuracy',optimal_accuracy_list)

    return optimal_accuracy_list, optimal_alpha_list


def control_nb_cells():
    # tuning of the x and z number of cells
    accuracy_list= []
    n_list= []
    alpha_list=[]
    n=2

    for alpha in (0.02,0.05,0.08):

        if n ==2 :
            print('surviving',n,alpha)
            g,plasma=comparison(1,16,n,0.95,0.95,18,18,3,100,5,5,5,alpha)

            accuracy=1-(np.sum(np.abs(g-plasma))/(np.sum(plasma)))
            accuracy_list.append(accuracy)
            n_list.append(n)
            alpha_list.append(alpha)
            print('mylist',accuracy_list)

    maximum=max(accuracy_list)
    print('max array',maximum)
    index_max=accuracy_list.index(maximum)
    print('index',index_max)
    print('optimum parameters','n=',n_list[index_max],'alpha=',alpha_list[index_max],'accuracy=',accuracy_list[index_max])
    return maximum,index_max

#control number of voxel
def control_nb_voxels():
    # tuning of the x and z number of cells
    accuracy_list= []
    n_list= []
    alpha_list=[]


    for alpha in (0.2,0.3,0.4):

        for n in (5,20):

            print('surviving',n,alpha)
            g,plasma=comparison(1,4,4,3,3,n,n,3,100,20,alpha)

            accuracy=1-(np.sum(np.abs(g-plasma))/(np.sum(plasma)))
            accuracy_list.append(accuracy)
            n_list.append(n)
            alpha_list.append(alpha)
            print('mylist',accuracy_list)

    maximum=max(accuracy_list)
    print('max array',maximum)
    index_max=accuracy_list.index(maximum)
    print('index',index_max)
    print('optimum parameters','n=',n_list[index_max],'alpha=',alpha_list[index_max],'accuracy=',accuracy_list[index_max])
    return maximum,index_max

#control distance to pinhole
def control_dist_pinhole():
 # trying for a 4x4, with its best para : nb voxel =15,alpha 0.3
    accuracy_list= []
    n_list= []
    alpha_list=[]


    for alpha in (0.12,0.15,0.17):

        for n in (8.7,9,9.3):

            print('surviving',n,alpha)
            g,plasma=comparison(0,30,3,0.98,0.112,20,20,3,100,n,n,n,alpha)
            plt.show()
            accuracy=1-(np.sum(np.abs(g-plasma))/(np.sum(plasma)))
            accuracy_list.append(accuracy)
            n_list.append(n)
            alpha_list.append(alpha)
            print('mylist',accuracy_list)

    maximum=max(accuracy_list)
    print('max array',maximum)
    index_max=accuracy_list.index(maximum)
    print('index',index_max)
    print('optimum parameters','distance=',n_list[index_max],'alpha =',alpha_list[index_max],'accuracy=',accuracy_list[index_max])
    return maximum,index_max

#max, imax=control_dist_pinhole()
#print('out of function', max,imax)
unitest()
#g,plasma = comparison(1,30,3,0.98,0.112,20,20,3,100,8.35,8.35,8.35,0.2)
#accuracy=1-(np.sum(np.abs(g-plasma))/(np.sum(plasma)))
#print('accuracy=',accuracy)
