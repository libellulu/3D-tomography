import numpy as np
from test_gaussian_V2 import gaussian_zz_cone
from test_gaussian_V2 import flattop
from test_gaussian_V2 import gaussian_3d
from algo_tomo_new import final_function
from algo_tomo_new import max_z_among_all_CCD
from reconstructions import tikhonov
import matplotlib.pyplot as plt
from collections import defaultdict

def comparison(printplot,nb_cell_x,nb_cell_z,spacing_x,spacing_z,nb_voxel_x,nb_voxel_y,nb_voxel_z,radius_tokamak,alpha):
    """
    Function that compares the reconstruction of the signal with the generated
    signals
    The plasma phantom signal is generated by gaussian_zz_cone and stored in
    scalar field values. The plasma generation can be change directly inside of
    this function (the argument of gaussian_zz_cone are not argument of comparison)
    The reconstruction is made by tikhonov, and the argument alpha is to be
    defined in the argument of comparison

    Parameters
    ----------
    printplot : 1 if we want to print the reconstruction picture, 0 otherwise
    nb_cell : the number of cell of the CCD in x or z
    spacing : the space between the center of two cell
    nb_voxel : discretization of the space in x,y, or z
    radius tokamak : for ISTTOK, 100
    pinhole distance to array : the distance between senser and pinhole, has to
    be tuned to get the best reconstruction
    alpha : alpha parameter of the reconstruction algorithm that weights the
    smoothness against the similarity of the reconstructed profile
    has to be tuned for the best reconstruction

    Returns
    -------
    g : the reconstructed signal
    scalar_field_value : the plasma phantom
    """
    real_projection,maxz=final_function(nb_cell_x,nb_cell_z,spacing_x,spacing_z,nb_voxel_x,nb_voxel_y,nb_voxel_z,radius_tokamak)

    # Test plot --------------------------------------------
    # In this example the distribution starts in the center,
    # and then moves to the top right corner while shrinking


    # Test gaussian_3d and flattop ------------------------------------------------------------

    x_min, x_max = (-100, 100)
    y_min, y_max = (-100, 100)
    z_min, z_max = (-4, 4)

    x_points, y_points, z_points = (nb_voxel_x,nb_voxel_y,nb_voxel_z)

    x_array = np.linspace(x_min, x_max, x_points)
    y_array = np.linspace(y_max, y_min, y_points)
    z_array = np.linspace(z_min, z_max, z_points)

    scalar_field_coordinates = np.meshgrid(z_array, y_array, x_array, indexing='ij')

    x_coordinates = scalar_field_coordinates[2].flatten()
    y_coordinates = scalar_field_coordinates[1].flatten()
    z_coordinates = scalar_field_coordinates[0].flatten()

    blob_z = np.linspace(-8, 8, 5)
    phantoms = []

    for z in blob_z:

        phantom = flattop(x=x_coordinates, y=y_coordinates,
                          center_x=0, center_y=0, width=85 * 2, height=1, degree=2)

        phantom += gaussian_3d(x=x_coordinates, y=y_coordinates, z=z_coordinates,
                               mu_x=20, mu_y=20, mu_z=z,
                               sigma_x=5, sigma_y=5, sigma_z=4,
                               height=4)

        phantoms.append(phantom.reshape((z_points, y_points, x_points)))

    if printplot==1:

        fig, axes = plt.subplots(len(phantoms), z_points)

        for sub_axes, phantom in zip(axes, phantoms):
            for ax, cross_section in zip(sub_axes, phantom):
                im = ax.pcolormesh(np.linspace(-100, 100, x_points + 1),
                                   np.linspace(100, -100, y_points + 1),
                                   cross_section,
                                   vmin=0, vmax=2)
                ax.set_aspect('equal', adjustable='box')

        fig.colorbar(im, ax=axes.ravel().tolist())

        plt.show()

    # Simulate tomography signals --------------------------------------------------

    fname = 'projections.npy'
    print('Reading:', fname)
    projections = np.load(fname)

    #print('projections:', projections.shape, projections.dtype)

    # -------------------------------------------------------------------------

    P = projections.reshape((projections.shape[0], -1))

    #print('P:', P.shape, P.dtype)

    g_list=[]
    signal_list=[]

    for i in range(0,len(phantoms)):
        signals = np.dot(P, phantoms[i].flatten())


        print('Signals:', signals.shape, signals.dtype)


        np.save("signals.npy", signals)
        np.save("phantom.npy", phantoms)

        g=tikhonov(signals,alpha)
        g_list.append(g)
        #
        # if printplot==1:
        #
        #     fig, axes = plt.subplots(1, len(g))
        #     for g_cut, ax in zip(g, axes):
        #         ax.imshow(g_cut)
        #     plt.show()

    if printplot==1:

        fig, axes = plt.subplots(len(g_list), z_points)

        for sub_axes, phantom in zip(axes, g_list):
            for ax, cross_section in zip(sub_axes, g):
                im = ax.pcolormesh(np.linspace(-100, 100, x_points + 1),
                                   np.linspace(100, -100, y_points + 1),
                                   cross_section,
                                   vmin=0, vmax=2)
                ax.set_aspect('equal', adjustable='box')

        # fig.colorbar(im, ax=axes.ravel().tolist())

        plt.show()

    return g_list,phantoms

def unitest():
    accuracy_list= []
    optimal_alpha_list=[]
    optimal_accuracy_list=[]
    alpha_list=[]
    for i in range(1):

        for alpha in [2000]:

            g,plasma=comparison(0,20,9,0.65,0.04,20,20,3,100,alpha)
            print('length of g',len(g))
            print('length plasma',len(plasma))
            accuracy=1-(np.sum(np.abs(g[i]-plasma[i]))/(np.sum(plasma[i])))
            print('serie',i)
            fig, axes = plt.subplots(1, len(g[i]))
            for g_cut, ax in zip(g[i], axes):
                ax.imshow(g_cut)
            plt.show()
            accuracy_list.append(accuracy)

            alpha_list.append(alpha)

            print('alpha', alpha)
            print('mylist',accuracy_list)
        print('serie',i)
        maximum=max(accuracy_list)

        print('max array',maximum)
        index_max=accuracy_list.index(maximum)
        alpha_max=alpha_list[index_max]
        #print('index',index_max)
        print('optimum parameters','alpha=',alpha_list[index_max],'accuracy=',accuracy_list[index_max])
        accuracy_list= []
        alpha_list=[]
        optimal_accuracy_list.append(maximum)
        optimal_alpha_list.append(alpha_max)
    print ('list of alphas',optimal_alpha_list)
    print('list of accuracy',optimal_accuracy_list)

    return optimal_accuracy_list, optimal_alpha_list


unitest()
