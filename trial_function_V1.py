import numpy as np
from test_gaussian_V1 import gaussian_zz_cone
from algo_tomo_new import final_function
from algo_tomo_new import max_z_among_all_CCD
from reconstructions import tikhonov
import matplotlib.pyplot as plt
from collections import defaultdict

def comparison(printplot,nb_cell_x,nb_cell_z,spacing_x,spacing_z,nb_voxel_x,nb_voxel_y,nb_voxel_z,radius_tokamak,alpha):
    """
    Function that compares the reconstruction of the signal with the generated
    signals
    The plasma phantom signal is generated by gaussian_zz_cone and stored in
    scalar field values. The plasma generation can be change directly inside of
    this function (the argument of gaussian_zz_cone are not argument of comparison)
    The reconstruction is made by tikhonov, and the argument alpha is to be
    defined in the argument of comparison

    Parameters
    ----------
    printplot : 1 if we want to print the reconstruction picture, 0 otherwise
    nb_cell : the number of cell of the CCD in x or z
    spacing : the space between the center of two cell
    nb_voxel : discretization of the space in x,y, or z
    radius tokamak : for ISTTOK, 100
    pinhole distance to array : the distance between senser and pinhole, has to
    be tuned to get the best reconstruction
    alpha : alpha parameter of the reconstruction algorithm that weights the
    smoothness against the similarity of the reconstructed profile
    has to be tuned for the best reconstruction

    Returns
    -------
    g : the reconstructed signal
    scalar_field_value : the plasma phantom
    """
    real_projection,distance_pinhole_CCD=final_function(nb_cell_x,nb_cell_z,spacing_x,spacing_z,nb_voxel_x,nb_voxel_y,nb_voxel_z,radius_tokamak)


    # Test plot --------------------------------------------
    # In this example the distribution starts in the center,
    # and then moves to the top right corner while shrinking


    x_min, x_max = (-100,100)
    y_min, y_max = (-100,100)
    z_min, z_max = (-0.2,0.2)

    x_points, y_points, z_points = (nb_voxel_x,nb_voxel_y,nb_voxel_z)

    x_array = np.linspace(x_min, x_max, x_points)
    y_array = np.linspace(y_max, y_min, y_points)
    z_array = np.linspace(z_min, z_max, z_points)

    scalar_field_coordinates = np.meshgrid(z_array, y_array, x_array, indexing='ij')

    x_coordinates = scalar_field_coordinates[2].flatten()
    y_coordinates = scalar_field_coordinates[1].flatten()
    z_coordinates = scalar_field_coordinates[0].flatten()

    scalar_field_values = gaussian_zz_cone(x=x_coordinates,
                                           y=y_coordinates,
                                           z=z_coordinates,
                                           base_1=-2, base_2=2,
                                           mu_x_1=0, mu_x_2=0,
                                           mu_y_1=0, mu_y_2=0,
                                           sigma_x_1=50, sigma_x_2=50,
                                           sigma_y_1=50, sigma_y_2=50,
                                           height_1=1, height_2=1)


    scalar_field_values += gaussian_zz_cone(x=x_coordinates,
                                            y=y_coordinates,
                                            z=z_coordinates,
                                            base_1=-2, base_2=2,
                                            mu_x_1=70, mu_x_2=-50,
                                            mu_y_1=80, mu_y_2=-30,
                                            sigma_x_1=10, sigma_x_2=10,
                                            sigma_y_1=10, sigma_y_2=10,
                                            height_1=1, height_2=1)

    scalar_field_values[x_coordinates**2 + y_coordinates**2 > 85**2] = 0.0

    scalar_field_values = scalar_field_values.reshape((z_points, y_points, x_points))




    if printplot==1:
        fig, axes = plt.subplots(1, len(scalar_field_values))

        for ax, cross_section in zip(axes, scalar_field_values):
            #ax.imshow(cross_section)
            ax.pcolormesh(np.linspace(-100,100,x_points+1),np.linspace(100,-100,y_points+1),cross_section)

            ax.set_aspect('equal', adjustable='box')

        plt.show()
    # Simulate tomography signals --------------------------------------------------

    fname = 'projections.npy'
    print('Reading:', fname)
    projections = np.load(fname)

    print('projections:', projections.shape, projections.dtype)

    # -------------------------------------------------------------------------

    P = projections.reshape((projections.shape[0], -1))

    print('P:', P.shape, P.dtype)

    signals = np.dot(P, scalar_field_values.flatten())

    print('Signals:', signals.shape, signals.dtype)

    np.save("signals.npy", signals)
    np.save("phantom.npy", scalar_field_values)


    g = tikhonov(signals,alpha)

    if printplot==1:

        fig, axes = plt.subplots(1, len(g))
        for g_cut, ax in zip(g, axes):
            #ax.imshow(g_cut)
            ax.pcolormesh(np.linspace(-100,100,x_points+1),np.linspace(100,-100,y_points+1),g_cut)

            ax.set_aspect('equal', adjustable='box')
        plt.show()
    return g,scalar_field_values

def unitest():
    """Function for when we want to try a specific combination of parameter and
    we just have to tune the alpha
    Will print the best alpha

    Parameters
    ----------
    None, the alpha and the parameters are changed in the declaration of the
    function and we call it without parameters

    Returns
    -------
    accuracy : the best accuracy
    index_max : the index in the lists where we have the parameters for this
    best accuracy
    """
    accuracy_list= []

    alpha_list=[]

    #for alpha in list(np.arange(2000,2500,50)):
    for alpha in[800] :
        g,plasma=comparison(1,20,9,0.65,0.04,20,20,3,100,alpha)
        accuracy=1-(np.sum(np.abs(g-plasma))/(np.sum(plasma)))
        accuracy_list.append(accuracy)

        alpha_list.append(alpha)
        print('alpha', alpha)
        print('mylist',accuracy_list)

    maximum=max(accuracy_list)
    print('max array',maximum)
    index_max=accuracy_list.index(maximum)
    print('index',index_max)
    print('optimum parameters','alpha=',alpha_list[index_max],'accurac=',accuracy_list[index_max])
    return maximum,index_max


    return accuracy


def control_nb_cells():
    """Function to try to determine the best nuber of cells, not used with
    a CCDof the market that already has a dtermined number. To be used if we
    want to construct our own CCD.

    Parameters
    ----------
    None, the alpha and the parameters are changed inside of the declaration
    of the
    function and we call it without parameters

    Returns
    -------
    accuracy : the best accuracy
    index_max : the index in the lists where we have the parameters for this
    best accuracy
    """
    # tuning of the x and z number of cells
    accuracy_list= []
    n_list= []
    alpha_list=[]


    for alpha in (0.02,0.05,0.08):

        for n in (2,8) :
            print('surviving',n,alpha)
            g,plasma=comparison(1,16,n,0.95,0.95,18,18,3,100,alpha)

            accuracy=1-(np.sum(np.abs(g-plasma))/(np.sum(plasma)))
            accuracy_list.append(accuracy)
            n_list.append(n)
            alpha_list.append(alpha)
            print('mylist',accuracy_list)

    maximum=max(accuracy_list)
    print('max array',maximum)
    index_max=accuracy_list.index(maximum)
    print('index',index_max)
    print('optimum parameters','n=',n_list[index_max],'alpha=',alpha_list[index_max],'accuracy=',accuracy_list[index_max])
    return maximum,index_max

#control number of voxel
def control_nb_voxels():
    """Function to try to determine the best number of voxel for the simulation.

    Parameters
    ----------
    None, the alpha and the parameters are changed inside of the declaration
    of the function and we call it without parameters

    Returns
    -------
    accuracy : the best accuracy
    index_max : the index in the lists where we have the parameters for this
    best accuracy
    """

    accuracy_list= []
    n_list= []
    alpha_list=[]


    for alpha in (700,1000,1200):

        for n in (15,18,20,25):

            #print('surviving',n,alpha)
            g,plasma=comparison(0,15,3,0.65,0.112,n,n,3,100,alpha)

            accuracy=1-(np.sum(np.abs(g-plasma))/(np.sum(plasma)))
            accuracy_list.append(accuracy)
            n_list.append(n)
            alpha_list.append(alpha)
            print('mylist',accuracy_list)

    maximum=max(accuracy_list)
    print('max array',maximum)
    index_max=accuracy_list.index(maximum)
    print('index',index_max)
    print('optimum parameters','n=',n_list[index_max],'alpha=',alpha_list[index_max],'accuracy=',accuracy_list[index_max])
    return maximum,index_max

#control distance to pinhole

def control_dist_pinhole():

    """Function to try to determine the best distance to the pinhole.
    Function that become useless now we have to fix this distance because
    we have a fixed slice in z to see.

    Parameters
    ----------
    None, the alpha and the parameters are changed inside of the declaration
    of the
    function and we call it without parameters

    Returns
    -------
    accuracy : the best accuracy
    index_max : the index in the lists where we have the parameters for this
    best accuracy
    """
    accuracy_list= []
    n_list= []
    alpha_list=[]


    for alpha in (0.09,0.12):

        for n in (8.7,9.3):

            print('surviving',n,alpha)
            g,plasma=comparison(0,30,3,0.98,0.112,30,30,3,100,n,n,n,alpha)
            plt.show()
            accuracy=1-(np.sum(np.abs(g-plasma))/(np.sum(plasma)))
            accuracy_list.append(accuracy)
            n_list.append(n)
            alpha_list.append(alpha)
            print('n',n,'alpha',alpha,'accuracy',accuracy)
            print('mylist',accuracy_list)

    maximum=max(accuracy_list)
    print('max array',maximum)
    index_max=accuracy_list.index(maximum)
    print('index',index_max)
    print('optimum parameters','n=',n_list[index_max],'alpha =',alpha_list[index_max],'accuracy=',accuracy_list[index_max])
    return maximum,index_max

#max, imax=control_nb_voxels()
#print('out of function', max,imax)
unitest()
